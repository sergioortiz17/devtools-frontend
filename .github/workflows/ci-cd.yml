name: Frontend CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      build_image:
        description: 'Build and push Docker image'
        required: false
        default: 'true'
        type: boolean
      deploy_dev:
        description: 'Deploy to dev cluster'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 002419998824.dkr.ecr.us-east-1.amazonaws.com
  IMAGE_REPO: devtools-frontend
  HELM_CHART_REPO: helm-charts/devtools-playground
  HELM_CHART_NAME: devtools-playground
  SONAR_ORG: sergioortiz17
  SONAR_PROJECT_KEY: sergioortiz17_devtools-frontend

jobs:
  # Job 0: SonarCloud Code Analysis
  sonarcloud-analysis:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    if: |
      github.event_name == 'push' ||
      github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Node.js dependencies
        run: |
          npm install

      - name: Run JavaScript tests with coverage
        run: |
          npm run test:coverage || true
        continue-on-error: true

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: .
          args: >
            -Dsonar.organization=${{ env.SONAR_ORG }}
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.host.url=https://sonarcloud.io
            -Dsonar.sources=src
            -Dsonar.exclusions=**/node_modules/**,**/dist/**,**/build/**,**/coverage/**,**/*.test.js,**/*.test.jsx,**/*.spec.js,**/*.spec.jsx
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.test.exclusions=**/*.test.js,**/*.test.jsx,**/*.spec.js,**/*.spec.jsx
            -Dsonar.language=js
            -Dsonar.github.repository=${{ github.repository }}
            -Dsonar.github.oauth=${{ secrets.GITHUB_TOKEN }}
            -Dsonar.branch.name=${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
            -Dsonar.branch.target=${{ github.event_name == 'pull_request' && github.base_ref || github.ref_name }}

  # Job 1: Build and push Docker image
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: sonarcloud-analysis
    permissions:
      id-token: write
      contents: read
    if: |
      (github.event_name == 'workflow_dispatch' && inputs.build_image == true) ||
      (github.event_name == 'push' && (needs.sonarcloud-analysis.result == 'success' || needs.sonarcloud-analysis.result == 'failure' || needs.sonarcloud-analysis.result == 'skipped'))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::002419998824:role/github-actions-devtools-playground
          role-session-name: GitHubActions-Frontend-Build
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image tags
        id: image-tags
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          BRANCH_NAME=${BRANCH_NAME//\//-}
          
          TAG="$SHORT_SHA"
          
          if [ "$BRANCH_NAME" != "main" ]; then
            TAG="$TAG,$BRANCH_NAME"
          fi
          
          if [ "$BRANCH_NAME" == "main" ]; then
            TAG="$TAG,latest"
          fi
          
          echo "tags=$TAG" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          build-args: |
            VITE_API_URL=/api
            VITE_APP_VERSION=${{ steps.image-tags.outputs.short_sha }}
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:${{ steps.image-tags.outputs.short_sha }}
            ${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:latest
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:buildcache
          cache-to: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:buildcache,mode=max

      - name: Output image URL
        run: |
          echo "## üê≥ Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:${{ steps.image-tags.outputs.short_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:latest\`" >> $GITHUB_STEP_SUMMARY

  # Job 2: Deploy to dev cluster
  deploy-dev:
    name: Deploy Frontend to Dev Cluster
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      id-token: write
      contents: read
    if: |
      github.event_name == 'workflow_dispatch' && inputs.deploy_dev == true ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::002419998824:role/github-actions-devtools-playground
          role-session-name: GitHubActions-Frontend-Deploy
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig --name vn-dev-eks --region ${{ env.AWS_REGION }}

      - name: Authenticate Helm with ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            helm registry login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

      - name: Get short SHA
        id: sha
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Verify image exists in ECR
        run: |
          echo "Verifying image exists in ECR..."
          IMAGE_TAG="${{ steps.sha.outputs.short_sha }}"
          aws ecr describe-images \
            --repository-name ${{ env.IMAGE_REPO }} \
            --image-ids imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }} || {
            echo "‚ö†Ô∏è Image tag $IMAGE_TAG not found, trying latest..."
            aws ecr describe-images \
              --repository-name ${{ env.IMAGE_REPO }} \
              --image-ids imageTag=latest \
              --region ${{ env.AWS_REGION }}
          }
          echo "‚úÖ Image verified in ECR"

      - name: Check if release exists and verify backend
        id: check-release
        run: |
          if helm list -n devtools-playground -q | grep -q "^${{ env.HELM_CHART_NAME }}$"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Release exists, will update only frontend"
            # Verificar si backend est√° desplegado para preservarlo
            if kubectl get deployment devtools-playground-backend -n devtools-playground &>/dev/null || \
               kubectl get deployment devtools-playground-backend-backend -n devtools-playground &>/dev/null; then
              echo "backend_deployed=true" >> $GITHUB_OUTPUT
              echo "Backend deployment detected, will preserve it"
            else
              echo "backend_deployed=false" >> $GITHUB_OUTPUT
              echo "No backend deployment found"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Release does not exist, will install with full values"
            echo "backend_deployed=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to EKS
        run: |
          echo "## üöÄ Deploying Frontend to EKS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Deploying with image tag: \`${{ steps.sha.outputs.short_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check-release.outputs.exists }}" == "true" ]; then
            # Release existe: actualizar frontend preservando backend
            echo "Updating existing release - frontend component (preserving backend)"
            
            # Construir comando helm upgrade preservando backend si est√° desplegado
            UPGRADE_CMD="helm upgrade ${{ env.HELM_CHART_NAME }} \
              oci://${{ env.ECR_REGISTRY }}/${{ env.HELM_CHART_REPO }} \
              --version 1.0.0 \
              --namespace devtools-playground \
              --reuse-values \
              --set frontend.enabled=true \
              --set frontend.image.tag=${{ steps.sha.outputs.short_sha }} \
              --set ingress.enabled=true \
              --set ingress.className=alb \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/load-balancer-type\"=external \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/scheme\"=internet-facing \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/target-type\"=ip \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/healthcheck-path\"=/ \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/certificate-arn\"=arn:aws:acm:us-east-1:002419998824:certificate/e4c80219-c644-4613-b901-4a8a8ddf5771 \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/listen-ports\"='[{\"HTTP\": 80}, {\"HTTPS\": 443}]' \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/ssl-policy\"=ELBSecurityPolicy-TLS-1-2-2017-01 \
              --set ingress.annotations.\"alb\.ingress\.kubernetes\.io/ssl-redirect\"=443"
            
            # Si backend est√° desplegado, asegurarse de mantenerlo habilitado
            if [ "${{ steps.check-release.outputs.backend_deployed }}" == "true" ]; then
              echo "Backend is deployed, preserving it by explicitly enabling it..."
              UPGRADE_CMD="$UPGRADE_CMD --set backend.enabled=true"
            fi
            
            eval $UPGRADE_CMD
          else
            # Release no existe: instalar con valores completos
            echo "Installing new release with full configuration"
            helm install ${{ env.HELM_CHART_NAME }} \
              oci://${{ env.ECR_REGISTRY }}/${{ env.HELM_CHART_REPO }} \
              --version 1.0.0 \
              --namespace devtools-playground \
              --create-namespace \
              --values helm/values-vn-dev.yaml \
              --set frontend.image.tag=${{ steps.sha.outputs.short_sha }}
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Helm deployment command completed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üåê Application URL: https://app.dryvn.org" >> $GITHUB_STEP_SUMMARY

      - name: Clean up nginx annotations from Ingress
        run: |
          echo "Cleaning up nginx annotations from Ingress..."
          # Eliminar anotaciones de nginx si existen
          kubectl annotate ingress -n devtools-playground \
            -l app.kubernetes.io/name=devtools-playground \
            nginx.ingress.kubernetes.io/rewrite-target- \
            nginx.ingress.kubernetes.io/ssl-redirect- \
            --overwrite || true
          
          echo "‚úÖ Ingress annotations cleaned"

      - name: Verify Ingress configuration
        run: |
          echo "=== Checking Ingress configuration ==="
          INGRESS_NAME=$(kubectl get ingress -n devtools-playground -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -z "$INGRESS_NAME" ]; then
            echo "‚ö†Ô∏è No Ingress found in namespace devtools-playground"
            kubectl get ingress -n devtools-playground
            exit 1
          fi
          
          echo "Ingress name: $INGRESS_NAME"
          echo ""
          echo "=== Ingress annotations ==="
          kubectl get ingress $INGRESS_NAME -n devtools-playground -o jsonpath='{.metadata.annotations}' | jq '.' || kubectl get ingress $INGRESS_NAME -n devtools-playground -o yaml | grep -A 20 "annotations:"
          
          echo ""
          echo "=== Ingress service backend ==="
          SERVICE_NAME=$(kubectl get ingress $INGRESS_NAME -n devtools-playground -o jsonpath='{.spec.rules[0].http.paths[0].backend.service.name}' 2>/dev/null || echo "")
          SERVICE_PORT=$(kubectl get ingress $INGRESS_NAME -n devtools-playground -o jsonpath='{.spec.rules[0].http.paths[0].backend.service.port.number}' 2>/dev/null || echo "")
          
          echo "Service name: $SERVICE_NAME"
          echo "Service port: $SERVICE_PORT"
          
          echo ""
          echo "=== Checking if service exists ==="
          if kubectl get svc $SERVICE_NAME -n devtools-playground >/dev/null 2>&1; then
            echo "‚úÖ Service $SERVICE_NAME exists"
            kubectl get svc $SERVICE_NAME -n devtools-playground
          else
            echo "‚ùå Service $SERVICE_NAME does NOT exist!"
            echo ""
            echo "Available services:"
            kubectl get svc -n devtools-playground
            exit 1
          fi
          
          echo ""
          echo "=== Ingress status (ALB hostname) ==="
          ALB_HOSTNAME=$(kubectl get ingress $INGRESS_NAME -n devtools-playground -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          if [ -n "$ALB_HOSTNAME" ]; then
            echo "‚úÖ ALB hostname: $ALB_HOSTNAME"
          else
            echo "‚ö†Ô∏è ALB hostname not yet assigned (may take a few minutes)"
          fi

      - name: Verify deployment
        timeout-minutes: 5
        run: |
          echo "Checking pods status..."
          kubectl get pods -n devtools-playground -l app.kubernetes.io/component=frontend
          
          echo ""
          echo "Waiting for rollout to complete (timeout: 5 minutes)..."
          kubectl rollout status deployment/devtools-playground-frontend -n devtools-playground --timeout=5m || {
            echo "‚ö†Ô∏è Rollout timeout or failed. Checking pod status..."
            kubectl describe pods -n devtools-playground -l app.kubernetes.io/component=frontend
            kubectl get events -n devtools-playground --sort-by='.lastTimestamp' | tail -20
            exit 1
          }
          
          echo ""
          echo "‚úÖ Deployment verified successfully!"
          kubectl get pods -n devtools-playground -l app.kubernetes.io/component=frontend


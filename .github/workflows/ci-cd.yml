name: Frontend CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      build_image:
        description: 'Build and push Docker image'
        required: false
        default: 'true'
        type: boolean
      deploy_dev:
        description: 'Deploy to dev cluster'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 002419998824.dkr.ecr.us-east-1.amazonaws.com
  IMAGE_REPO: devtools-frontend
  HELM_CHART_REPO: helm-charts/devtools-playground
  HELM_CHART_NAME: devtools-playground-frontend
  SONAR_ORG: sergioortiz17
  SONAR_PROJECT_KEY: sergioortiz17_devtools-frontend

jobs:
  # Job 0: SonarCloud Code Analysis
  sonarcloud-analysis:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    if: |
      github.event_name == 'push' ||
      github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Node.js dependencies
        run: |
          npm install

      - name: Run JavaScript tests with coverage
        run: |
          npm run test:coverage || true
        continue-on-error: true

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: .
          args: >
            -Dsonar.organization=${{ env.SONAR_ORG }}
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.host.url=https://sonarcloud.io
            -Dsonar.sources=src
            -Dsonar.exclusions=**/node_modules/**,**/dist/**,**/build/**,**/coverage/**,**/*.test.js,**/*.test.jsx,**/*.spec.js,**/*.spec.jsx
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.test.exclusions=**/*.test.js,**/*.test.jsx,**/*.spec.js,**/*.spec.jsx
            -Dsonar.language=js
            -Dsonar.github.repository=${{ github.repository }}
            -Dsonar.github.oauth=${{ secrets.GITHUB_TOKEN }}
            -Dsonar.branch.name=${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
            -Dsonar.branch.target=${{ github.event_name == 'pull_request' && github.base_ref || github.ref_name }}

  # Job 1: Build and push Docker image
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: sonarcloud-analysis
    permissions:
      id-token: write
      contents: read
    if: |
      (github.event_name == 'workflow_dispatch' && inputs.build_image == true) ||
      (github.event_name == 'push' && (needs.sonarcloud-analysis.result == 'success' || needs.sonarcloud-analysis.result == 'failure' || needs.sonarcloud-analysis.result == 'skipped'))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::002419998824:role/github-actions-devtools-playground
          role-session-name: GitHubActions-Frontend-Build
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image tags
        id: image-tags
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          BRANCH_NAME=${BRANCH_NAME//\//-}
          
          TAG="$SHORT_SHA"
          
          if [ "$BRANCH_NAME" != "main" ]; then
            TAG="$TAG,$BRANCH_NAME"
          fi
          
          if [ "$BRANCH_NAME" == "main" ]; then
            TAG="$TAG,latest"
          fi
          
          echo "tags=$TAG" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          build-args: |
            VITE_API_URL=/api
            VITE_APP_VERSION=${{ steps.image-tags.outputs.short_sha }}
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:${{ steps.image-tags.outputs.short_sha }}
            ${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:latest
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:buildcache
          cache-to: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:buildcache,mode=max

      - name: Output image URL
        run: |
          echo "## üê≥ Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:${{ steps.image-tags.outputs.short_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.ECR_REGISTRY }}/${{ env.IMAGE_REPO }}:latest\`" >> $GITHUB_STEP_SUMMARY

  # Job 2: Deploy to dev cluster
  deploy-dev:
    name: Deploy Frontend to Dev Cluster
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      id-token: write
      contents: read
    if: |
      github.event_name == 'workflow_dispatch' && inputs.deploy_dev == true ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::002419998824:role/github-actions-devtools-playground
          role-session-name: GitHubActions-Frontend-Deploy
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig --name vn-dev-eks --region ${{ env.AWS_REGION }}

      - name: Authenticate Helm with ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            helm registry login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

      - name: Get short SHA
        id: sha
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Verify image exists in ECR
        run: |
          echo "Verifying image exists in ECR..."
          IMAGE_TAG="${{ steps.sha.outputs.short_sha }}"
          aws ecr describe-images \
            --repository-name ${{ env.IMAGE_REPO }} \
            --image-ids imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }} || {
            echo "‚ö†Ô∏è Image tag $IMAGE_TAG not found, trying latest..."
            aws ecr describe-images \
              --repository-name ${{ env.IMAGE_REPO }} \
              --image-ids imageTag=latest \
              --region ${{ env.AWS_REGION }}
          }
          echo "‚úÖ Image verified in ECR"

      - name: Deploy to EKS
        run: |
          echo "## üöÄ Deploying Frontend to EKS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Deploying with image tag: \`${{ steps.sha.outputs.short_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "Release name: \`${{ env.HELM_CHART_NAME }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          helm upgrade --install ${{ env.HELM_CHART_NAME }} \
            oci://${{ env.ECR_REGISTRY }}/${{ env.HELM_CHART_REPO }} \
            --version 1.0.0 \
            --namespace devtools-playground \
            --create-namespace \
            --values helm/values-vn-dev.yaml \
            --set frontend.enabled=true \
            --set frontend.image.tag=${{ steps.sha.outputs.short_sha }} \
            --set backend.enabled=false \
            --set frontend.nginxConfigMap.enabled=false
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Helm deployment command completed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üåê Application URL: https://app.dryvn.org" >> $GITHUB_STEP_SUMMARY

      - name: Fix nginx ConfigMap with correct backend service name
        if: always()
        run: |
          echo "üîß Fixing nginx ConfigMap with correct backend service name..."
          
          # Find the nginx ConfigMap for the frontend
          CONFIGMAP_NAME=$(kubectl get configmap -n devtools-playground -o name | grep -E "(frontend.*nginx|nginx.*frontend)" | head -1 | cut -d/ -f2 || echo "")
          
          if [ -z "$CONFIGMAP_NAME" ]; then
            # Try alternative naming pattern
            CONFIGMAP_NAME=$(kubectl get configmap -n devtools-playground -o name | grep nginx | grep frontend | head -1 | cut -d/ -f2 || echo "")
          fi
          
          if [ -z "$CONFIGMAP_NAME" ]; then
            echo "‚ö†Ô∏è No nginx ConfigMap found, chart may not be creating one"
            exit 0
          fi
          
          echo "Found ConfigMap: $CONFIGMAP_NAME"
          
          # Create nginx.conf with correct backend service name
          cat > /tmp/nginx.conf << 'NGINX_EOF'
server {
  listen 80;
  server_name localhost;
  root /usr/share/nginx/html;
  index index.html;

  # Security headers
  add_header X-Frame-Options "SAMEORIGIN" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-XSS-Protection "1; mode=block" always;

  # Gzip compression
  gzip on;
  gzip_vary on;
  gzip_min_length 1024;
  gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json;

  # Cache static assets
  location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
  }

  # Proxy API requests to backend
  # IMPORTANT: Using correct backend service name: devtools-playground-backend-backend
  # (NOT devtools-playground-frontend-backend which the chart incorrectly generates)
  location /api {
    rewrite ^/api(.*) $1 break;
    proxy_pass http://devtools-playground-backend-backend.devtools-playground.svc.cluster.local:8000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
  }

  # Main SPA routing
  location / {
    try_files $uri $uri/ /index.html;
  }

  # Health check endpoint
  location /health {
    access_log off;
    return 200 "healthy\n";
    add_header Content-Type text/plain;
  }
}
NGINX_EOF

          # Update the ConfigMap
          kubectl create configmap "$CONFIGMAP_NAME" \
            --from-file=nginx.conf=/tmp/nginx.conf \
            -n devtools-playground \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ ConfigMap '$CONFIGMAP_NAME' updated successfully with correct backend service name"
          
          # Verify the update
          echo ""
          echo "Verifying ConfigMap content:"
          kubectl get configmap "$CONFIGMAP_NAME" -n devtools-playground -o jsonpath='{.data.nginx\.conf}' | grep -A 2 "proxy_pass" || echo "‚ö†Ô∏è Could not verify proxy_pass in ConfigMap"
          
          # Restart pods to pick up the new ConfigMap
          echo ""
          echo "Restarting frontend pods to pick up the updated ConfigMap..."
          DEPLOYMENT_NAME=""
          if kubectl get deployment devtools-playground-frontend-frontend -n devtools-playground &>/dev/null; then
            DEPLOYMENT_NAME="devtools-playground-frontend-frontend"
          elif kubectl get deployment devtools-playground-frontend -n devtools-playground &>/dev/null; then
            DEPLOYMENT_NAME="devtools-playground-frontend"
          fi
          
          if [ -n "$DEPLOYMENT_NAME" ]; then
            kubectl rollout restart deployment/$DEPLOYMENT_NAME -n devtools-playground
            echo "‚úÖ Deployment restarted"
          else
            echo "‚ö†Ô∏è Could not find deployment to restart"
          fi

      - name: Verify deployment
        timeout-minutes: 5
        run: |
          echo "Checking pods status..."
          # Try both possible deployment names
          DEPLOYMENT_NAME=""
          if kubectl get deployment devtools-playground-frontend-frontend -n devtools-playground &>/dev/null; then
            DEPLOYMENT_NAME="devtools-playground-frontend-frontend"
          elif kubectl get deployment devtools-playground-frontend -n devtools-playground &>/dev/null; then
            DEPLOYMENT_NAME="devtools-playground-frontend"
          else
            echo "‚ö†Ô∏è Deployment not found. Listing all deployments:"
            kubectl get deployments -n devtools-playground
            exit 1
          fi
          
          echo "Using deployment: $DEPLOYMENT_NAME"
          kubectl get pods -n devtools-playground -l app.kubernetes.io/component=frontend
          
          echo ""
          echo "Waiting for rollout to complete (timeout: 5 minutes)..."
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n devtools-playground --timeout=5m || {
            echo "‚ö†Ô∏è Rollout timeout or failed. Checking pod status..."
            kubectl describe pods -n devtools-playground -l app.kubernetes.io/component=frontend
            kubectl get events -n devtools-playground --sort-by='.lastTimestamp' | tail -20
            exit 1
          }
          
          echo ""
          echo "‚úÖ Deployment verified successfully!"
          kubectl get pods -n devtools-playground -l app.kubernetes.io/component=frontend

